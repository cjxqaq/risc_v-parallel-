经过近两个星期的努力，最终也只是完成了带有分支预测的五级流水线的并行结构。

第一个版本是串行，当时我的想法很简单，将五级流水封装成五个函数IF(),ID(),EX(),MEM(),WB()；寄存器与内存仅仅是两个开在全局的简单数组。再在全局创建一些变量用于函数之间也就是五级流水之间的数据传递，然后分别在这五个函数内分别实现五级流水的功能，再加上一个read()函数将输入的十六进制码转换成内存里的数据。所以串行阶段的main函数是这个样子
int main(){
read();
while(1){
IF();
ID();
EX();
MEM();
WB();
}
}
原本的设想是在串行阶段所有的结构均不封装成类，也就是所有代码全部放在一个.cpp里，全部依靠switch和注释来寻找与标志结构中的不同功能。之前打算在串行改并行阶段将其进行重新封装，然而最后还是没用改。
虽然这样做的结果是寻找某个特定的功能时有点麻烦，但是整体结构还算清晰，而且能够避免一些未知的BUG，而且如果之后想再进行封装我想应该也不会很困难。
所有代码装在一个.cpp里还有一个好处：运行速度快，串行阶段2900MS，并行3000多MS，加入分支预测后也只有4000MS出头

第二个版本，串行改并行就是把main函数里while内的函数反过来，即
int main(){
read();
while(1){
WB();
MEM();
EX();
ID();
IF();
}
}
然后再修改函数，同时把串行时每句指令用的同一个（几个）变量改成了每个结构的独特变量，当然他们还是存放在全局范围。与此同时，加入了状态标记，标记该部分的流水结构是否已经完成，以防逻辑上的上一个结构还没运行就去执行该结构，或是该结构以及运行过了，但是还没有人接受它的上一次处理出的数据。
这是对于我所使用的“唯一cpp”所需的可能比较独特的处理办法，其他的比如寄存器锁，内存锁或者pc锁就是共通的东西。
这时的并行实现的是完全的等待闲置，所有可能的跳转，访问即将存入但未存入的寄存器或内存时，都无脑等待直到危险操作过去。

	调试直到并行能够正常运行了就开始写第三个版本——带分支预测的并行。起初写的是全部跳转，主要目的是把预测后的错误处理做好，发现预测准确率基本能达到50%以上。我试图把BEQ改成全部不跳转，发现对预测准确率的影响不大，此时开始写基于历史跳转记录的分支预测。
首先是在全局对于上两次B-TYPE的是否跳转记录，之后的跳转就由上两次记录决定。发现对预测准确度的提高很小，便开始尝试对B-TYPE的六种不同分支分别记录，每次是否跳转由自己前两次是否跳转决定。
这种情况下qsort 和pi及superloop的跳转准确率可以到达80%以上。
Forwarding暂时没写。
